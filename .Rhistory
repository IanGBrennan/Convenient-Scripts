if(sample.strategy=="assemblage") {
for (i in 1:length(groups)) {
curr.group <- subset(dataframe, dataframe[,colnum]==groups[i])
mean.age <- ((curr.group$Min_Age[1]+curr.group$Max_Age[1])/2)
#if(length(mean.age==0)){normal <- 0}
if(distribution.type=="normal"){curr.group$Sampled_Age <- rnorm(1, mean.age, sd(c(mean.age, curr.group$Min_Age[1], curr.group$Max_Age[1]))) }
if(distribution.type=="uniform"){curr.group$Sampled_Age <- runif(1, curr.group$Min_Age[1], curr.group$Max_Age[1])}
curr.group$Sampled_Age[curr.group$Sampled_Age < 0] <- 0
Random_Age <- rbind(Random_Age, curr.group)
}
}
#dataframe <- cbind(dataframe, Random_Age)
return(Random_Age)
}
# Now, create a second function to repeat this step a number of times
lotsa.lines <- function(dataframe, group, reps, dist.type=c("normal", "uniform"), line.color="gray", plot.lines=T,
time.max=15, time.min=0, est.points=FALSE, mean.points=FALSE, sampled.points=FALSE) {
plot(1, type="n", ylim=c(0.4,1.8), xlim=c(time.max, time.min), xlab="Millions of years before present (Myr)", ylab= "Lower Molar Crown Height")
Error<-dataframe[dataframe$Higher_tax==group,]
count=0
mean.table <- NULL
while(count < reps+1){
coloR <- randomColor(1)
Error <- inc.unc(Error, group.type="Assemblage", sample.strategy="assemblage", distribution.type=dist.type)
smoothingSpline = smooth.spline(Error$Sampled_Age, Error$HI, spar=0.5)
#lines(smoothingSpline, col=alpha(coloR,0.3), lwd=3)
if(plot.lines==TRUE){lines(smoothingSpline, col=alpha(line.color,0.3), lwd=3)}
if(sampled.points==TRUE){points(Error$Sampled_Age, Error$HI, cex=2, pch=19, col=alpha(line.color,0.01))}
mean.table <- cbind(mean.table, Error$Sampled_Age)
Error$Sampled_Age <- NULL
count = count+1
}
### Group specific trend using the 'Estimated Ages' provided by C&P
smoothingSpline = smooth.spline(Error$Est_age, Error$HI, spar=0.5)
lines(smoothingSpline, col="gray", lwd=6)
if(est.points==TRUE){points(Error$Est_age, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
### Mean of the age ranges (min/max bounds) provided by C&P
age.df <- Error[,c("Min_Age", "Max_Age")]
mean.df <- apply(age.df, 1, mean)
if(mean.points==TRUE){points(mean.df, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
smoothingSpline = smooth.spline(mean.df, Error$HI, spar=0.5)
lines(smoothingSpline, col="black", lwd=6)
return(list(ages=mean.table, mean.ages=Error$mean.line, traits = Error$HI))
}
# Now, create a second function to repeat this step a number of times
lotsa.lines <- function(dataframe, class, group, reps, dist.type=c("normal", "uniform"), line.color="gray", plot.lines=T,
time.max=15, time.min=0, est.points=FALSE, mean.points=FALSE, sampled.points=FALSE) {
plot(1, type="n", ylim=c(0.4,1.8), xlim=c(time.max, time.min), xlab="Millions of years before present (Myr)", ylab= "Lower Molar Crown Height")
if(class=="Higher_tax"){Error<-dataframe[dataframe$Higher_tax==group,]}
if(class=="Tribe"){Error<-dataframe[dataframe$tribe==group,]}
count=0
mean.table <- NULL
while(count < reps+1){
coloR <- randomColor(1)
Error <- inc.unc(Error, group.type="Assemblage", sample.strategy="assemblage", distribution.type=dist.type)
smoothingSpline = smooth.spline(Error$Sampled_Age, Error$HI, spar=0.5)
#lines(smoothingSpline, col=alpha(coloR,0.3), lwd=3)
if(plot.lines==TRUE){lines(smoothingSpline, col=alpha(line.color,0.3), lwd=3)}
if(sampled.points==TRUE){points(Error$Sampled_Age, Error$HI, cex=2, pch=19, col=alpha(line.color,0.01))}
mean.table <- cbind(mean.table, Error$Sampled_Age)
Error$Sampled_Age <- NULL
count = count+1
}
### Group specific trend using the 'Estimated Ages' provided by C&P
smoothingSpline = smooth.spline(Error$Est_age, Error$HI, spar=0.5)
lines(smoothingSpline, col="gray", lwd=6)
if(est.points==TRUE){points(Error$Est_age, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
### Mean of the age ranges (min/max bounds) provided by C&P
age.df <- Error[,c("Min_Age", "Max_Age")]
mean.df <- apply(age.df, 1, mean)
if(mean.points==TRUE){points(mean.df, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
smoothingSpline = smooth.spline(mean.df, Error$HI, spar=0.5)
lines(smoothingSpline, col="black", lwd=6)
return(list(ages=mean.table, mean.ages=Error$mean.line, traits = Error$HI))
}
lotsa.lines(tdata, class="Higher_tax", "Macropodinae", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=F, sampled.points=T) # original color is "orange"
lotsa.lines(tdata, class="Higher_tax", "Macropodinae", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=F, sampled.points=T) # original color is "orange"
lotsa.lines(tdata, class="Tribe", "Macropodini", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=F, sampled.points=T) # original color is "orange"
filter(tdata, Tribe=="Macropodini")
testo <- filter(tdata, Tribe=="Macropodini")
inc.unc(testo, "Assemblage", "uniform", "assemblage")
lotsa.lines(tdata, class="Tribe", "Macropodini", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=F, sampled.points=T) # original color is "orange"
inc.unc(testo, "Assemblage", "uniform", "assemblage")
inc.unc(testo, "Assemblage", "uniform", "assemblage")
inc.unc(testo, "Assemblage", "uniform", "assemblage")
inc.unc(testo, "Assemblage", "uniform", "assemblage")
# Now, create a second function to repeat this step a number of times
lotsa.lines <- function(dataframe, class, group, reps, dist.type=c("normal", "uniform"), line.color="gray", plot.lines=T,
time.max=15, time.min=0, est.points=FALSE, mean.points=FALSE, sampled.points=FALSE) {
plot(1, type="n", ylim=c(0.4,1.8), xlim=c(time.max, time.min), xlab="Millions of years before present (Myr)", ylab= "Lower Molar Crown Height")
if(class=="Higher_tax"){Error<-dataframe[dataframe$Higher_tax==group,]}
if(class=="Tribe"){Error<-dataframe[dataframe$tribe==group,]}
count=0
mean.table <- NULL
while(count < reps+1){
coloR <- randomColor(1)
Error <- inc.unc(Error, group.type="Assemblage", sample.strategy="assemblage", distribution.type=dist.type)
smoothingSpline = smooth.spline(Error$Sampled_Age, Error$HI, spar=0.5)
#lines(smoothingSpline, col=alpha(coloR,0.3), lwd=3)
if(plot.lines==TRUE){lines(smoothingSpline, col=alpha(line.color,0.3), lwd=3)}
if(sampled.points==TRUE){points(Error$Sampled_Age, Error$HI, cex=2, pch=19, col=alpha(line.color,0.01))}
mean.table <- cbind(mean.table, Error$Sampled_Age)
Error$Sampled_Age <- NULL
count = count+1
}
### Group specific trend using the 'Estimated Ages' provided by C&P
smoothingSpline = smooth.spline(Error$Est_age, Error$HI, spar=0.5)
lines(smoothingSpline, col="gray", lwd=6)
if(est.points==TRUE){points(Error$Est_age, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
### Mean of the age ranges (min/max bounds) provided by C&P
age.df <- Error[,c("Min_Age", "Max_Age")]
mean.df <- apply(age.df, 1, mean)
if(mean.points==TRUE){points(mean.df, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
smoothingSpline = smooth.spline(mean.df, Error$HI, spar=0.5)
lines(smoothingSpline, col="black", lwd=6)
return(list(ages=mean.table, mean.ages=Error$mean.line, traits = Error$HI))
}
lotsa.lines(tdata, class="Tribe", "Macropodini", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=F, sampled.points=T) # original color is "orange"
inc.unc(testo, "Assemblage", "uniform", "assemblage")
inc.unc(testo, "Assemblage", "uniform", "assemblage")
inc.unc(testo, "Assemblage", "uniform", "assemblage")
dataframe=tdata
group.type="Assemblage"
rm(group.type)
class="Tribe"
group="Macropodini"
reps=10
dist.type="uniform"
line.color="red"
plot.lines=T
time.max=15
time.min=0
est.points=FALSE
mean.points=FALSE
sampled.points=FALSE
plot(1, type="n", ylim=c(0.4,1.8), xlim=c(time.max, time.min), xlab="Millions of years before present (Myr)", ylab= "Lower Molar Crown Height")
(class=="Higher_tax")
(class=="Tribe")
if(class=="Tribe"){Error<-dataframe[dataframe$tribe==group,]}
Error
if(class=="Tribe"){Error<-dataframe[dataframe$Tribe==group,]}
Error
rm(dataframe, class, group, reps, dist.type, line.color, plot.lines, time.max, time.min, est.points, mean.points, sampled.points count(i))
rm(i)
rm(dataframe, class, group, reps, dist.type, line.color, plot.lines, time.max, time.min, est.points, mean.points, sampled.points, counts)
class
lotsa.lines(tdata, class="Tribe", "Macropodini", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=F, sampled.points=T) # original color is "orange"
# Now, create a second function to repeat this step a number of times
lotsa.lines <- function(dataframe, class, group, reps, dist.type=c("normal", "uniform"), line.color="gray", plot.lines=T,
time.max=15, time.min=0, est.points=FALSE, mean.points=FALSE, sampled.points=FALSE) {
plot(1, type="n", ylim=c(0.4,1.8), xlim=c(time.max, time.min), xlab="Millions of years before present (Myr)", ylab= "Lower Molar Crown Height")
if(class=="Higher_tax"){Error<-dataframe[dataframe$Higher_tax==group,]}
if(class=="Tribe"){Error<-dataframe[dataframe$Tribe==group,]}
count=0
mean.table <- NULL
while(count < reps+1){
coloR <- randomColor(1)
Error <- inc.unc(Error, group.type="Assemblage", sample.strategy="assemblage", distribution.type=dist.type)
smoothingSpline = smooth.spline(Error$Sampled_Age, Error$HI, spar=0.5)
#lines(smoothingSpline, col=alpha(coloR,0.3), lwd=3)
if(plot.lines==TRUE){lines(smoothingSpline, col=alpha(line.color,0.3), lwd=3)}
if(sampled.points==TRUE){points(Error$Sampled_Age, Error$HI, cex=2, pch=19, col=alpha(line.color,0.01))}
mean.table <- cbind(mean.table, Error$Sampled_Age)
Error$Sampled_Age <- NULL
count = count+1
}
### Group specific trend using the 'Estimated Ages' provided by C&P
smoothingSpline = smooth.spline(Error$Est_age, Error$HI, spar=0.5)
lines(smoothingSpline, col="gray", lwd=6)
if(est.points==TRUE){points(Error$Est_age, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
### Mean of the age ranges (min/max bounds) provided by C&P
age.df <- Error[,c("Min_Age", "Max_Age")]
mean.df <- apply(age.df, 1, mean)
if(mean.points==TRUE){points(mean.df, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
smoothingSpline = smooth.spline(mean.df, Error$HI, spar=0.5)
lines(smoothingSpline, col="black", lwd=6)
return(list(ages=mean.table, mean.ages=Error$mean.line, traits = Error$HI))
}
Error
rm(Error)
lotsa.lines(tdata, class="Tribe", "Macropodini", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=F, sampled.points=T) # original color is "orange"
lotsa.lines(tdata, class="Tribe", "Dendrolagini", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=T, sampled.points=F) # original color is "orange"
lotsa.lines(tdata, class="Tribe", "Dorcopsini", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=T, sampled.points=F) # original color is "orange"
filter(tdata, Tribe=="Dorcopsini")
mpalette
showCols(mpalette)
barplot(1:length(mpalette), col=mpalette)
palette(mpalette)
lotsa.lines(tdata, class="Tribe", "Macropodini", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#01985c", plot.lines=T, sampled.points=F) # original color is "orange"
lotsa.lines(tdata, class="Tribe", "Dendrolagini", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#8cdb5e", plot.lines=T, sampled.points=F) # original color is "orange"
lotsa.lines(tdata, class="Tribe", "Dorcopsini", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=T, sampled.points=F) # original color is "orange"
#xdata=read.table("/Users/Ian/Desktop/Macropod_Dating/Couzens&Prideaux2018_dryad_package/data/Couzens&Prideaux_data2018_macrowear.txt", header=T, sep="\t")# open crownH_all
xdata=read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/CP_Macropod_2018/data/Couzens&Prideaux_data2018_macrowear.csv", header=T)# open crownH_all
assemblage.ages <- read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FULL_Assemblage_Ages.csv", header=T, row.names=1)
tdata <- xdata[,c("ID", "Taxon", "Higher_tax", "Macropodin_status", "Tribe", "Assemblage", "Est_age", "WS", "TI")]
names(tdata) <-  c("ID", "Taxon", "Higher_tax", "Macro_stat", "Tribe",      "Assemblage", "Est_age", "WS", "TI")
# Can't remember how to do this without doing a for-loop, ask ZOE!
Max_Age <- NULL; for(i in 1:nrow(tdata)){Max_Age <- append(Max_Age, assemblage.ages[which(rownames(assemblage.ages) == tdata[i,"Assemblage"]), "CP_Max"])}; tdata$Max_Age <- Max_Age
Min_Age <- NULL; for(i in 1:nrow(tdata)){Min_Age <- append(Min_Age, assemblage.ages[which(rownames(assemblage.ages) == tdata[i,"Assemblage"]), "CP_Min"])}; tdata$Min_Age <- Min_Age
lotsa.lines.ws <- function(dataframe, class, group, reps, dist.type=c("normal", "uniform"), line.color="gray", plot.lines=FALSE,
time.max=15, time.min=0, est.points=FALSE, mean.points=FALSE, sampled.points=FALSE) {
plot(1, type="n", ylim=c(1,7), xlim=c(time.max, time.min), xlab="Millions of years before present (Myr)", ylab= "Dental Macrowear")
if(class=="Higher_tax"){Error<-dataframe[dataframe$Higher_tax==group,]}
if(class=="Tribe"){Error<-dataframe[dataframe$Tribe==group,]}
count=0
mean.table <- NULL
while(count < reps+1){
coloR <- randomColor(1)
Error <- inc.unc(Error, group.type="Assemblage", sample.strategy="assemblage", distribution.type=dist.type)
smoothingSpline = smooth.spline(Error$Sampled_Age, Error$WS, spar=0.5)
#lines(smoothingSpline, col=alpha(coloR,0.3), lwd=3)
if(plot.lines==TRUE){lines(smoothingSpline, col=alpha(line.color,0.3), lwd=3)}
if(sampled.points==TRUE){points(Error$Sampled_Age, Error$WS, cex=2, pch=19, col=alpha(line.color,0.01))}
mean.table <- cbind(mean.table, Error$Sampled_Age)
Error$Sampled_Age <- NULL
count = count+1
}
### Group specific trend using the 'Estimated Ages' provided by C&P
smoothingSpline = smooth.spline(Error$Est_age, Error$WS, spar=0.5)
lines(smoothingSpline, col="gray", lwd=6)
if(est.points==TRUE){points(Error$Est_age, Error$WS, cex=2, pch=19, col=alpha("black",0.3))}
### Mean of the age ranges (min/max bounds) provided by C&P
age.df <- Error[,c("Min_Age", "Max_Age")]
mean.df <- apply(age.df, 1, mean)
if(mean.points==TRUE){points(mean.df, Error$WS, cex=2, pch=19, col=alpha("black",0.3))}
smoothingSpline = smooth.spline(mean.df, Error$WS, spar=0.5)
lines(smoothingSpline, col="black", lwd=6)
return(list(ages=mean.table, mean.ages=Error$mean.line, traits = Error$HI))
}
lotsa.lines.ws(tdata, "Higher_tax", "Macropodinae", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E") # original color is "orange"
lotsa.lines.ws(tdata, "Higher_tax", "Macropodinae", 100, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E") # original color is "orange"
lotsa.lines.ws(tdata, "Higher_tax", "Macropodinae", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=T) # original color is "orange"
lotsa.lines.ws(tdata, "Tribe", "Macropodini", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=T) # original color is "orange"
lotsa.lines.ws(tdata, "Tribe", "Dendrolagini", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#8cdb5e", plot.lines=T) # original color is "orange"
lotsa.lines.ws(tdata, "Tribe", "Macropodini", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#01985c", plot.lines=T) # original color is "orange"
lotsa.lines.ws(tdata, "Tribe", "Dendrolagini", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#8cdb5e", plot.lines=T) # original color is "orange"
lotsa.lines.ws <- function(dataframe, class, group, reps, dist.type=c("normal", "uniform"), line.color="gray", plot.lines=FALSE,
time.max=15, time.min=0, est.points=FALSE, mean.points=FALSE, sampled.points=FALSE) {
plot(1, type="n", ylim=c(1,7), xlim=c(time.max, time.min), xlab="Millions of years before present (Myr)", ylab= "Dental Macrowear")
if(class=="Higher_tax"){Error<-dataframe[dataframe$Higher_tax==group,]}
if(class=="Tribe"){Error<-dataframe[dataframe$Tribe==group,]}
if(class=="Genus"){Error<-dataframe[dataframe$Genus==group,]}
count=0
mean.table <- NULL
while(count < reps+1){
coloR <- randomColor(1)
Error <- inc.unc(Error, group.type="Assemblage", sample.strategy="assemblage", distribution.type=dist.type)
smoothingSpline = smooth.spline(Error$Sampled_Age, Error$WS, spar=0.5)
#lines(smoothingSpline, col=alpha(coloR,0.3), lwd=3)
if(plot.lines==TRUE){lines(smoothingSpline, col=alpha(line.color,0.3), lwd=3)}
if(sampled.points==TRUE){points(Error$Sampled_Age, Error$WS, cex=2, pch=19, col=alpha(line.color,0.01))}
mean.table <- cbind(mean.table, Error$Sampled_Age)
Error$Sampled_Age <- NULL
count = count+1
}
### Group specific trend using the 'Estimated Ages' provided by C&P
smoothingSpline = smooth.spline(Error$Est_age, Error$WS, spar=0.5)
lines(smoothingSpline, col="gray", lwd=6)
if(est.points==TRUE){points(Error$Est_age, Error$WS, cex=2, pch=19, col=alpha("black",0.3))}
### Mean of the age ranges (min/max bounds) provided by C&P
age.df <- Error[,c("Min_Age", "Max_Age")]
mean.df <- apply(age.df, 1, mean)
if(mean.points==TRUE){points(mean.df, Error$WS, cex=2, pch=19, col=alpha("black",0.3))}
smoothingSpline = smooth.spline(mean.df, Error$WS, spar=0.5)
lines(smoothingSpline, col="black", lwd=6)
return(list(ages=mean.table, mean.ages=Error$mean.line, traits = Error$HI))
}
#xdata=read.table("/Users/Ian/Desktop/Macropod_Dating/Couzens&Prideaux2018_dryad_package/data/Couzens&Prideaux_data2018_macrowear.txt", header=T, sep="\t")# open crownH_all
xdata=read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/CP_Macropod_2018/data/Couzens&Prideaux_data2018_macrowear.csv", header=T)# open crownH_all
assemblage.ages <- read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FULL_Assemblage_Ages.csv", header=T, row.names=1)
tdata <- xdata[,c("ID", "Taxon", "Higher_tax", "Macropodin_status", "Tribe", "Assemblage", "Est_age", "WS", "TI")]
names(tdata) <-  c("ID", "Taxon", "Higher_tax", "Macro_stat", "Tribe",      "Assemblage", "Est_age", "WS", "TI")
# Can't remember how to do this without doing a for-loop, ask ZOE!
Max_Age <- NULL; for(i in 1:nrow(tdata)){Max_Age <- append(Max_Age, assemblage.ages[which(rownames(assemblage.ages) == tdata[i,"Assemblage"]), "CP_Max"])}; tdata$Max_Age <- Max_Age
Min_Age <- NULL; for(i in 1:nrow(tdata)){Min_Age <- append(Min_Age, assemblage.ages[which(rownames(assemblage.ages) == tdata[i,"Assemblage"]), "CP_Min"])}; tdata$Min_Age <- Min_Age
lotsa.lines.ws(tdata, "Genus", "Macropus", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#01985c", plot.lines=T) # original color is "orange"
head(tdata)
#xdata=read.table("/Users/Ian/Desktop/Macropod_Dating/Couzens&Prideaux2018_dryad_package/data/Couzens&Prideaux_data2018_macrowear.txt", header=T, sep="\t")# open crownH_all
xdata=read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/CP_Macropod_2018/data/Couzens&Prideaux_data2018_macrowear.csv", header=T)# open crownH_all
assemblage.ages <- read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FULL_Assemblage_Ages.csv", header=T, row.names=1)
tdata <- xdata[,c("ID", "Taxon", "Higher_tax", "Macropodin_status", "Tribe", "Genus", "Assemblage", "Est_age", "WS", "TI")]
names(tdata) <-  c("ID", "Taxon", "Higher_tax", "Macro_stat", "Tribe", "Genus", "Assemblage", "Est_age", "WS", "TI")
# Can't remember how to do this without doing a for-loop, ask ZOE!
Max_Age <- NULL; for(i in 1:nrow(tdata)){Max_Age <- append(Max_Age, assemblage.ages[which(rownames(assemblage.ages) == tdata[i,"Assemblage"]), "CP_Max"])}; tdata$Max_Age <- Max_Age
Min_Age <- NULL; for(i in 1:nrow(tdata)){Min_Age <- append(Min_Age, assemblage.ages[which(rownames(assemblage.ages) == tdata[i,"Assemblage"]), "CP_Min"])}; tdata$Min_Age <- Min_Age
lotsa.lines.ws(tdata, "Genus", "Macropus", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#01985c", plot.lines=T) # original color is "orange"
lotsa.lines.ws(tdata, "Genus", "Dendrolagus", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#01985c", plot.lines=T) # original color is "orange"
lotsa.lines.ws(tdata, "Genus", "Petrogale", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#01985c", plot.lines=T) # original color is "orange"
lotsa.lines.ws(tdata, "Genus", "Thylogale", 10, dist.type = "uniform", time.max=20, time.min=0, line.color="#01985c", plot.lines=T) # original color is "orange"
lotsa.lines.ws(tdata, "Genus", "Macropus", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#01985c", plot.lines=T)
lotsa.lines.ws(tdata, "Genus", "Dendrolagus", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#8cdb5e", plot.lines=T)
lotsa.lines.ws(tdata, "Genus", "Petrogale", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#8cdb5e", plot.lines=T)
#xdata=read.table("/Users/Ian/Desktop/Macropod_Dating/Couzens&Prideaux2018_dryad_package/data/Couzens&Prideaux_data2018_crownheight.txt", header=T, sep="\t")
xdata=read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/CP_Macropod_2018/data/Couzens&Prideaux_data2018_crownheight.csv", header=T)
assemblage.ages <- read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FULL_Assemblage_Ages.csv", header=T, row.names=1)
#xdata1<-subset(xdata, TI %in% c("2","3"))
# Establish the Hypsodonty Index (HI)
HI = as.numeric(as.vector(xdata$H_HYPCD))/xdata$PW
xdata = data.frame(xdata, HI)
tdata <- na.omit(xdata[c("ID","Higher_tax","Macropodin_status", "Tribe", "Genus", "Est_age","HI", "Assemblage")])
# Can't remember how to do this without doing a for-loop, ask ZOE!
Max_Age <- NULL; for(i in 1:nrow(tdata)){Max_Age <- append(Max_Age, assemblage.ages[which(rownames(assemblage.ages) == tdata[i,"Assemblage"]), "CP_Max"])}; tdata$Max_Age <- Max_Age
Min_Age <- NULL; for(i in 1:nrow(tdata)){Min_Age <- append(Min_Age, assemblage.ages[which(rownames(assemblage.ages) == tdata[i,"Assemblage"]), "CP_Min"])}; tdata$Min_Age <- Min_Age
# Now, create a second function to repeat this step a number of times
lotsa.lines <- function(dataframe, class, group, reps, dist.type=c("normal", "uniform"), line.color="gray", plot.lines=T,
time.max=15, time.min=0, est.points=FALSE, mean.points=FALSE, sampled.points=FALSE) {
plot(1, type="n", ylim=c(0.4,1.8), xlim=c(time.max, time.min), xlab="Millions of years before present (Myr)", ylab= "Lower Molar Crown Height")
if(class=="Higher_tax"){Error<-dataframe[dataframe$Higher_tax==group,]}
if(class=="Tribe"){Error<-dataframe[dataframe$Tribe==group,]}
if(class=="Genus"){Error<-dataframe[dataframe$Genus==group,]}
count=0
mean.table <- NULL
while(count < reps+1){
coloR <- randomColor(1)
Error <- inc.unc(Error, group.type="Assemblage", sample.strategy="assemblage", distribution.type=dist.type)
smoothingSpline = smooth.spline(Error$Sampled_Age, Error$HI, spar=0.5)
#lines(smoothingSpline, col=alpha(coloR,0.3), lwd=3)
if(plot.lines==TRUE){lines(smoothingSpline, col=alpha(line.color,0.3), lwd=3)}
if(sampled.points==TRUE){points(Error$Sampled_Age, Error$HI, cex=2, pch=19, col=alpha(line.color,0.01))}
mean.table <- cbind(mean.table, Error$Sampled_Age)
Error$Sampled_Age <- NULL
count = count+1
}
### Group specific trend using the 'Estimated Ages' provided by C&P
smoothingSpline = smooth.spline(Error$Est_age, Error$HI, spar=0.5)
lines(smoothingSpline, col="gray", lwd=6)
if(est.points==TRUE){points(Error$Est_age, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
### Mean of the age ranges (min/max bounds) provided by C&P
age.df <- Error[,c("Min_Age", "Max_Age")]
mean.df <- apply(age.df, 1, mean)
if(mean.points==TRUE){points(mean.df, Error$HI, cex=2, pch=19, col=alpha("black",0.3))}
smoothingSpline = smooth.spline(mean.df, Error$HI, spar=0.5)
lines(smoothingSpline, col="black", lwd=6)
return(list(ages=mean.table, mean.ages=Error$mean.line, traits = Error$HI))
}
lotsa.lines(tdata, class="Genus", "Macropus", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=T, sampled.points=F) # original color is "orange"
lotsa.lines(tdata, class="Genus", "Dendrolagus", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=T, sampled.points=F) # original color is "orange"
lotsa.lines(tdata, class="Genus", "Dendrolagus", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=T, sampled.points=F) # original color is "orange"
filter(tdata, Genus=="Dendrolagus")
lotsa.lines(tdata, class="Genus", "Petrogale", 1000, dist.type = "uniform", time.max=20, time.min=0, line.color="#FFCE4E", plot.lines=T, sampled.points=F) # original color is "orange"
#
test.trees <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FossilUncertainty/Trees/Macro_AgesRanges_NEWICK.trees")
test.trees <- test.trees[900:1000]
test.trees
lapply(test.trees, function(x) max(nodeHeights(test.trees[[x]])))
max(nodeHeights(test.trees[[1]]))
class(test.trees)
check.age <- function(tree){max(nodeHeights(tree))}
lapply(test.trees, check.age)
as.vector(lapply(test.trees, check.age))
unlist(lapply(test.trees, check.age))
lapply(test.trees, max, nodeheights(test.trees[[x]]))
lapply(test.trees, max, nodeHeights(test.trees[[x]]))
lapply(test.trees, max, nodeHeights(test.trees))
test.trees <- test.trees[990:1000]
check.age <- function(tree){max(nodeHeights(tree))}
unlist(lapply(test.trees, check.age))
#
test.trees <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FossilUncertainty/Trees/Macro_AgesRanges_NEWICK.trees")
test.trees <- test.trees[990:1000]
check.age <- function(tree){max(nodeHeights(tree))}
unlist(lapply(test.trees, check.age))
tree.ages <- unlist(lapply(test.trees, check.age))
which(tree.ages < 30)
class(tree.ages[[1]])
tree.ages <- unlist(lapply(test.trees, check.age)); names(tree.ages) <- NULL
tree.ages
which(tree.ages < 30)
#
test.trees <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FossilUncertainty/Trees/Macro_AgesRanges_NEWICK.trees")
test.trees <- test.trees[990:1000]
#
test.trees <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FossilUncertainty/Trees/Macro_AgesRanges_NEWICK.trees")
test.trees <- test.trees[990:1000]
check.age <- function(tree){max(nodeHeights(tree))}
tree.ages <- unlist(lapply(test.trees, check.age)); #names(tree.ages) <- NULL
sort(tree.ages)
order(tree.ages)
sort(test.trees)
testi <- sapply(test.trees, function(x) max(nodeHeights(test.trees[[x]])))
sapply(test.trees, function(x) max(nodeHeights(x)))
tree.ages <- sapply(test.trees, function(x) max(nodeHeights(x)))
tree.ages
sorted.trees <- test.trees[order(tree.ages, increasing=T)]
test.trees
length(test.trees)
length(tree.ages)
sorted.trees <- test.trees[order(tree.ages, decreasing=T)]
sapply(sorted.trees, function(x) max(nodeHeights(x)))
sorted.trees <- test.trees[order(tree.ages, decreasing=F)]
sapply(sorted.trees, function(x) max(nodeHeights(x)))
#
test.trees <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FossilUncertainty/Trees/Macro_AgesRanges_NEWICK.trees")
test.trees <- test.trees[990:1000]
tree.ages <- sapply(test.trees, function(x) max(nodeHeights(x)))
sorted.trees <- test.trees[order(tree.ages, decreasing=F)]; names(sorted.trees) <- NULL
sapply(sorted.trees, function(x) max(nodeHeights(x)))
macro.data <- read.csv("/Users/Ian/Desktop/Macropod_Dating/Couzens&Prideaux2018_dryad_package/data/CrownHeight_Data.csv", header=T)
min.tree <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Macro_MinAges_Constrained_PF/Macro_MinAges_HKY_Constrained_CON.tre")
macro.data <- read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/CP_Macropod_2018/data/CrownHeight_Data.csv", header=T)
min.tree <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Macro_MinAges_Constrained_PF/Macro_MinAges_HKY_Constrained_CON.tre")
mean.tree <-read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Macro_MeanAges_Constrained/Macro_MeanAges_HKY_Constrained_CON.tre")
max.tree <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Macro_MaxAges_Constrained_PF/Macro_MaxAges_HKY_Constrained_CON_fixed.tre")
cp.min <-   read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Macro_CPMinAges_Constrained_PF/Macro_CP_MinAges_CON.tre")
cp.mean <-  read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Macro_CPEstAges_Constrained_PF/Macro_CP_EstAges_CON.tre")
cp.max <-   read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Macro_CPMaxAges_Constrained_PF/Macro_CP_MaxAges_CON.tre")
enviro.data <- read.csv("/Users/Ian/Desktop/Macropod_Dating/Andrea_S1.csv", header=T)
enviro.data <- read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Andrea_S1.csv", header=T)
enviro.data <- read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FossilUncertainty/Data/Andrae_S1.csv", header=T)
flux.data <-   read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FossilUncertainty/Data/Aeolian_Flux.csv", header=T)
#sp.means <- read.csv("/Users/Ian/Desktop/Macropod_Dating/Couzens&Prideaux2018_dryad_package/data/CrownHeight_spMEANS.csv", header=T)
sp.means <- read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/CP_Macropod_2018/data/CrownHeight_Macropodinae_spMEANS.csv", header=T)
sp.means
# Trim tree and data down to overlapping taxa
overlaps <- intersect(min.tree$tip.label, unique(macro.data$Taxon))
trim.tree <- drop.tip(mean.tree, setdiff(mean.tree$tip.label, overlaps))
trim.data <- filter(macro.data, Taxon %in% overlaps)
plot(trim.tree)
# OR trim tree and data down to just Macropodinae
macros <- filter(macro.data, Higher_tax == "Macropodinae")
overlaps <- intersect(min.tree$tip.label, unique(macros$Taxon))
trim.tree <- drop.tip(mean.tree, setdiff(mean.tree$tip.label, overlaps))
trim.data <- filter(macros, Taxon %in% overlaps)
plot(trim.tree)
Ntip(trim.tree)
trim.data
sp.means
#
test.trees <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/FossilUncertainty/Trees/Macro_AgesRanges_NEWICK.trees")
test.trees <- test.trees[990:1000]
tree.ages <- sapply(test.trees, function(x) max(nodeHeights(x)))
tree.ages
sorted.trees <- test.trees[order(tree.ages, decreasing=F)]; names(sorted.trees) <- NULL
sapply(sorted.trees, function(x) max(nodeHeights(x)))
# Create polytomies
collapse.to.star<-function(tree,node){
tt<-splitTree(tree,split=list(node=node,bp=tree$edge.length[which(tree$edge[,2]==node)]))
ss<-starTree(species=tt[[2]]$tip.label,branch.lengths=diag(vcv(tt[[2]])))
ss$root.edge<-0
tree<-paste.tree(tt[[1]],ss)
return(tree)
}
testo <- test.trees[[1]]
plot(testo)
getMRCA(testo, c("Setonix_brachyurus", "Macropus_rufus"))
testo <- extract.clade(test.trees[[1]], 75)
testo
plot(testo)
plot(testo); nodelabels(cex=0.5)
testa <- collapse.to.star(testo, 40)
plot(testa)
testa <- collapse.to.star(testo, 29)
testa <- collapse.to.star(testo, 29); plot(testa)
base.tree <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/REAL_Macropodinae_ALL/All_Macropodinae_FBD_Relax.trees")
base.tree <- read.tree("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/REAL_Macropodinae_ALL/All_Macropodinae_FBD_Relax.trees")
base.tree <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/REAL_Macropodinae_ALL/All_Macropodinae_FBD_Relax.trees")
base.tree <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/REAL_Macropodinae_ALL")
base.tree <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/REAL_Macropodinae_ALL/All_Macropodinae_FBD_Relax.trees")
base.tree <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Smallest_MorphOnly/Small/Macropodoidea_MorphOnly_SetonixRecode.trees")
base.tree <- ape::read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Smallest_MorphOnly/Small/Macropodoidea_MorphOnly_SetonixRecode.trees")
base.tree <- phytools::read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Macropod_Dating/Operators/Smallest_MorphOnly/Small/Macropodoidea_MorphOnly_SetonixRecode.trees")
# this is the sample info pulled from the tip names
t1 <- read.csv("/Users/Ian/Google.Drive/ANU Herp Work/Lemmon Projects/T545_Egernia/Egernia_SampleInfo.csv", header=T)
library(ape)
library(phytools)
##################################################################################
## Here's another way which may be simpler and more valuable
##################################################################################
# read in your alignment
align.file <- read.dna("/Users/Ian/Google.Drive/ANU Herp Work/Lemmon Projects/T545_Egernia/mtGenomes/Egernia_RefAligned_Assemblies_1_2_RENAMED.fasta", format="fasta")
# make a function to check how much missing data there is
checkMissing <- function(alignment, taxon.file, count.gaps.as.missing=TRUE, print.df=TRUE, missing.threshold=NULL){
library(ape); library(seqinr)
# I'm going to use the quick and dirty approach of getting a percentage of missing data
# to identify taxa we might want to remove
# But it might be worth it to think about using a base composition or content method
# like 'baseContent' in the 'spiderDev' package to do this as well
# the only worry is that it'll consistently flag outgroups
#full.align <- read.dna(paste0(sub.dir, paste0(alignment, ".fasta")), format="fasta")
full.align <- alignment
if(count.gaps.as.missing==TRUE) {missing.bases <- c(2, 240, 4)} else missing.bases <- c(2,240)
missing.sum <- apply(full.align, MARGIN = 1, FUN = function(x) length(which(as.numeric(x) %in% missing.bases)))
missing.percent <- missing.sum/ncol(full.align)
missing.df <- data.frame(new_tip_label=names(missing.percent), mitoGenome_percent_incomplete=missing.percent); rownames(missing.df)<-NULL
if(print.df==TRUE){print(missing.df)}
new.data <- dplyr::left_join(taxon.file, missing.df)
return(new.data)
if(!is.null(missing.threshold)){
bad.names <- names(which(missing.percent >= missing.threshold))
print(paste("dropping", bad.names))
good.names <- setdiff(rownames(full.align), bad.names)
new.align <- full.align[which(rownames(full.align) %in% good.names), ]
write.FASTA(new.align, paste0(sub.dir, paste0(alignment,"_Reduced"),".fasta"))
cat(c("your reduced alignment is now called:\n",
paste0(sub.dir, paste0(alignment,"_Reduced"),".fasta")))
} else cat(c("your alignment has not been changed"))
}
# spit out the sample info file with the
new.info <- checkMissing(alignment=align.file, taxon.file=t1, count.gaps.as.missing=TRUE, missing.threshold=NULL, print.df=FALSE)
incomplete <- new.info[complete.cases(new.info$mitoGenome_percent_incomplete),]
incomplete
missing <- data.frame(percent_missing = incomplete$mitoGenome_percent_incomplete*100)
missing
rownames(missing) <- incomplete$new_tip_label
missing$other <- 100 - missing$percent_missing
missed <- missing[match(egtree$tip.label, rownames(missing)),] # probably not necessary, but maybe useful
egtree <- read.nexus("/Users/Ian/Google.Drive/ANU Herp Work/Lemmon Projects/T545_Egernia/mtGenomes/Egernia_RefAligned_Assemblies_1_2_RENAMED.fasta.contree")
missed <- missing[match(egtree$tip.label, rownames(missing)),] # probably not necessary, but maybe useful
missed["Scincella_reference"] <- c(0,100)
# plot the data against the tree, but make sure you haven't done some thing like ladderize(egtree)
plotTree.barplot(egtree, missed, add=TRUE,
args.barplot=list(xlab="Percent Missing Data", col=c("darkblue", "lightBlue"), border=F))
